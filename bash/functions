#!/usr/bin/bash

# FileName: functions
# FileType: bash
# Descript: some function for better experience

#{ Colors
# ANSI ESCAPE CODE:
# Just choose color
# ESC = \033
# basic format : ESC[<arg>;<argn>m"string"
# ESC[0m is default output type
# 3/4 bit color foregroud : <arg> = n, and n in {30 ... 37 + 90 .. 97}
# 3/4 bit color backgroud : <arg> = n, and n in {40 ... 47 + 100 .. 107}
# 8 bit color foregroud : <arg> = 38;5;n, and n in {0 ... 255}
# 8 bit color backgroup : <arg> = 48;5;n, and n in {0 ... 255}
# 24 bit color foregroup : <arg> = 38;2;r;g;b, and r,g,b in {0 ... 255}
# 24 bit color backgroup : <arg> = 48;2;r;g;b, and r,g,b in {0 ... 255}

case $(tput colors) in
    "256")
        declare -A colorlist=([black]='0;0;0' [red]='255;0;0' [green]='0;128;0' \
            [yellow]='255;255;0' [blue]='0;0;255' [purple]='255;0;255' [magenta]='255;0;255' \
            [cyan]='0;255;255' [lightblue]='0;255;255' [white]='255;255;255')
        fore_prefix='38;2;'
        back_prefix='48;2;';;

    "8")
        declare -A colorlist=([black]=0 [red]=1 [green]=2 \
            [yellow]=3 [blue]=4 [purple]=5 [magenta]=5 \
            [cyan]=6 [lightblue]=6 [white]=7 [preety]=167)
        fore_prefix='38;5;'
        back_prefix='48;5;';;
    *)
        declare -A colorlist=([black]=30 [red]=31 [green]=32 [yellow]=33 \
            [blue]=34 [purple]=35 [magenta]=35 [cyan]=36 [lightblue]=36 [white]=37)
        declare -A bg_colorlist=([black]=40 [red]=41 [green]=42 [yellow]=43 \
            [blue]=44 [purple]=45 [magenta]=45 [cyan]=46 [lightblue]=46 [white]=47)
        fore_prefix=''
        back_prefix='';;
esac

# Other settings
declare -A fonttype=([b]='1;' [i]='3;' [u]='4;')

# Define color functions
for color in ${!colorlist[@]}; do
    # Foreground
    eval "${color}()
    {
        printf \"\\033[${fore_prefix}${colorlist[$color]}m\${*}\\033[0m\"
    }"
    for ftype in ${!fonttype[@]}; do
        eval "${color}${ftype}()
        {
            printf \"\\033[${fonttype[$ftype]}${fore_prefix}${colorlist[$color]}m\${*}\\033[0m\"
        }"
    done
    # Background
    if [ -z ${!bg_colorlist[@]} ]; then
        eval "B${color}()
        {
            printf \"\\033[${back_prefix}${colorlist[$color]}m\${*}\\033[0m\"
        }"
        for ftype in ${!fonttype[@]}; do
            eval "B${color}${ftype}()
            {
                printf \"\\033[${fonttype[$ftype]}${back_prefix}${colorlist[$color]}m\${*}\\033[0m\"
            }"
        done
    else
        eval "B${color}()
        {
            printf \"\\033[${back_prefix}${bg_colorlist[$color]}m\${*}\\033[0m\"
        }"
        for ftype in ${!fonttype[@]}; do
            eval "B${color}${ftype}()
            {
                printf \"\\033[${fonttype[$ftype]}${back_prefix}${bg_colorlist[$color]}m\${*}\\033[0m\"
            }"
        done
    fi
done
#}

## WARNING and ERROR functions
#{ function : _warn()
_warn()
{
    echo -e "$(red WARNING) : $(blueb ${*} )" && return 0
}
#}
#{ function : _error()
_error()
{
    echo -e "$(red ERROR) : $(blueb ${*})" && return 1
}
#}

## create files that from ONE DIR symbol link to OTHER DIR, depth is <$3>
#{ function : dir_files_link_depth() <src, dest, depth>
dir_files_link_depth()
{
    # A vain error check statesment
    [ ${#@} -eq 3 ] || (_error "Function parameters error." && return 1)
    [ -d $1 ] || (__warn "Directory $(purple $1)> don't exist." && return 0)
    [ -d $2 ] || (mkdir -p $2 || (_warning "Directory $(purple $2) don't exist, and can't make it." \
        || return 1))
    all_fl=$(find $1 -maxdepth $3 -type f)
    all_fl+=$(find $1 -maxdepth $3 -type l)
    for files in $all_fl; do
        if ([ -e "$2/${files##*/}" ] || [ -h "$2/${files##*/}" ]); then
            _warn "$(purple "$2/${files##*/}") already exsits, give up"
            continue
        fi
        ln -s $files $2 || _warn "Create symbol link $(purple $files) failure."
    done
    return 0
}
#}
## syntatic sugar by dir_files_link_depth()
#{ function : dir_files_link()
dir_files_link()
{
    dir_files_link_depth $1 $2 1
}
#}
#{ function : dir_files_link_all(), maxdepth is seted to 255
dir_files_link_all()
{
    dir_files_link_depth $1 $2 255
}
#}

#{ function: assert()
assert()
{
    [ -n "$@" ] || exit 1
    (eval "$@") && return 0 \
        ||  echo -e "$(red "!!!!")  $(greenu "$@") is $(blueb "false")"
    exit 1
}
#}

## integer arithmetic function
#{ function: i_max() <array_ref> <dest_ref>
i_max()
{
    [ $# -eq 2 ] || return 1
    local -n __array=$1
    local -n __ret=$2
    local -i __first=0
    for __num in ${__array[@]}; do
        [[ "$__num" =~ ^[-0-9]*$ ]] || return 1
        [ $__first -eq 0 ] && __ret=$__num && __first=1 && continue
        [ $__num -gt $__ret ] && __ret=$__num
    done
    return 0
}
#}
#{ function: i_min() <array_ref> <dest_ref>
i_min()
{
    [ $# -eq 2 ] || return 1
    local -n __array=$1
    local -n __ret=$2
    local -i __first=0
    for __num in ${__array[@]}; do
        [[ "$__num" =~ ^[-0-9]*$ ]] || return 1
        [ $__first -eq 0 ] && __ret=$__num && __first=1 && continue
        [ $__num -lt $__ret ] && __ret=$__num
    done
    return 0
}
#}

#{ function: get_fd() <ret_ref> -- aviliable file descriptor
get_fd()
{
    [ $# -eq 1 ] || return 1
    local -n __found=$1
    __found=-1
    for fd in {0..200}; do
        rco="$(true 2>/dev/null >&${fd}; echo $?)"
        rci="$(true 2>/dev/null <&${fd}; echo $?)"
        [[ "${rco}${rci}" = "11" ]] && __found=${fd} && break
    done
    [ $__found -eq -1 ] && return 1
    return 0
}
#}

## follow and replace symlink with file be pointed
#{ function: __fsymlink() -- it's dangerous to manipulate directory...
__fsymlink()
{
    [ $# -eq 1 ] || return 1
    [ -h $1 ] || return 1
    local SRET_CALL="return 0"
    local FRET_CALL="return 1"
    while(true); do
        local -i avi
        get_fd avi || break
        eval "exec $avi>&1 1>/dev/null"
        SRET_CALL="eval \"exec 1>&$avi\" && return 0"
        FRET_CALL="eval \"exec 1>&$avi\" && return 1"
        break
    done
    local __dir=${1%/*}
    [ -d $__dir ] || __dir="./"
    local __file=${1##*/}
    local __tdir=$(ls -l $1 | cut -d\> -f 2 | cut -f 2 -d\ )
    echo $__tdir
    [ -n "$__dir" ] && pushd $__dir
    local __pwd=${PWD}
    rm -f $__file || (([ -n "$__dir" ] && popd) && eval $FRET_CALL)
    cp -r "$__tdir" "$__pwd/$__file" || (([ -n "$__dir" ] && popd) && eval $FRET_CALL)
    popd && eval $SRET_CALL
}
#}
